---
title: "Unit Testing Lifecycle and State in Android ViewModels"
date: "2025-06-26"
excerpt: "A practical guide on testing Android ViewModel lifecycle events, state, and logic with JUnit and coroutines."
tags:
  - Android
  - ViewModel
  - Testing
  - Kotlin
---

# Unit Testing Lifecycle and State in Android ViewModels

When developing Android apps, ensuring your ViewModel logic behaves correctly under various lifecycle events is essential. This post shows how to **unit test ViewModels** in Kotlin using modern patterns like **coroutines, StateFlow, and LiveData**.

> The goal is to make sure your business logic survives configuration changes and remains easy to test.

---

## Why Test ViewModels?

- Decouple UI from business logic
- Ensure consistent state transitions
- Catch regressions early

ViewModels hold your screen's state. They shouldn't know about the Activity or Fragment lifecycle directly, but they often need to handle **"events"** (like refreshing data or reacting to user interactions).

---



## Typical ViewModel Example

Here's a simplified ViewModel with a repository and state:

```kotlin
@HiltViewModel
class UserViewModel @Inject constructor(
    private val repo: UserRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow<UserState>(UserState.Loading)
    val uiState: StateFlow<UserState> = _uiState

    init {
        loadUser()
    }

    fun loadUser() {
        viewModelScope.launch {
            try {
                val user = repo.fetchUser()
                _uiState.value = UserState.Success(user)
            } catch (e: Exception) {
                _uiState.value = UserState.Error(e)
            }
        }
    }
}```




